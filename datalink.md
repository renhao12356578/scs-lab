**选择重传协议 (Selective Repeat ARQ, SR)**。

选择重传协议是数据链路层（有时也用于传输层）用于实现可靠数据传输的一种自动重传请求 (ARQ) 机制。它属于窗口协议的一种，旨在提高在有差错通道上的传输效率。

为了更好地理解选择重传，我们通常将其与另外两种基本的 ARQ 协议进行比较：

1.  **停等协议 (Stop-and-Wait ARQ):** 发送方发送一个帧后必须等待接收方的确认 (ACK) 才能发送下一个帧。简单但效率极低。
2.  **回退 N 帧协议 (Go-Back-N ARQ, GBN):** 发送方可以连续发送多个帧（在一个窗口内），无需等待每个帧的确认。接收方只按顺序接收并发送累积确认 (Cumulative ACK) 或单个确认。**关键缺点：** 如果某个帧丢失，接收方会丢弃所有后续到达的帧（即使它们是正确接收的）。发送方超时后，必须从丢失的那个帧开始，重传所有后续帧（“回退 N 帧”）。这在丢包率高的网络中效率很低。

**选择重传协议 (Selective Repeat ARQ, SR)** 的目标是克服 GBN 在丢包时的低效率。

**核心思想:**

*   **发送方:** 可以发送一个窗口内的多个帧。为每个已发送但未确认的帧设置一个独立的定时器。
*   **接收方:** **可以接受并缓冲**到达但失序的帧，只要这些帧的序号在接收窗口内。接收方为每个正确接收的帧发送一个单独的确认 (ACK)，即使是失序到达的。
*   **重传:** 发送方只有在某个帧的定时器超时后，才**只重传那个特定的帧**，而不是像 GBN 那样重传整个窗口后续的帧。

**工作机制详解:**

SR 协议需要发送方和接收方各自维护一个窗口，并且通常要求发送窗口大小等于接收窗口大小。

**1. 发送方:**

*   **发送窗口 (Sender Window):** 维护一个范围，表示可以发送但尚未被确认的帧的序号。窗口大小为 `W_S`。
*   **缓冲区:** 发送方需要缓冲窗口内的所有已发送但未确认的帧，以便进行可能的重传。
*   **定时器:** 为发送窗口内的**每一个**已发送但未确认的帧启动一个独立的定时器。
*   **收到上层数据:** 如果发送窗口未满，发送方从上层获取数据，分配下一个序号，将帧放入发送缓冲区，发送该帧，并启动该帧的定时器。发送窗口右移。
*   **收到 ACK:**
    *   如果收到的 ACK 的序号 `n` 在发送方的窗口内，表示序号为 `n` 的帧已被接收方正确接收。发送方将序号 `n` 的帧标记为已确认，并停止其定时器。
    *   如果发送窗口中序号**最小**的那个帧（窗口的基序号）被确认了，则发送窗口向前滑动（右移），移动的格数等于从基序号开始连续被确认的帧的数量。每滑动一格，就可以从上层发送一个新帧（如果上层有数据的话），并启动新帧的定时器。
    *   如果收到的 ACK 序号在窗口之外，则通常丢弃该 ACK。
*   **定时器超时:** 如果某个帧 `n` 的定时器超时，发送方认为该帧丢失，会**只重传**帧 `n`，并重新启动帧 `n` 的定时器。

**2. 接收方:**

*   **接收窗口 (Receiver Window):** 维护一个范围，表示接收方当前愿意接受的帧的序号。窗口大小为 `W_R`，通常等于 `W_S`。
*   **缓冲区:** 接收方需要缓冲那些在接收窗口内但**失序**到达的帧。
*   **期望接收序号 (RcvBase):** 表示接收方期望接收的按序到达的下一个帧的序号。这是接收窗口的基序号。
*   **收到帧:**
    *   检查到达帧的序号 `n` 是否在接收窗口内 (`RcvBase <= n < RcvBase + W_R`)。
    *   **如果序号在窗口内:**
        *   接收方接收该帧。
        *   **发送一个针对该帧序号 `n` 的单独 ACK。** (这是一个与 GBN 的重要区别)。
        *   如果该帧是失序的，将其放入接收缓冲区。
        *   **如果该帧恰好是期望接收的按序到达的帧 (`n == RcvBase`)：**
            *   将该帧向上层交付。
            *   检查接收缓冲区中是否有序号连续的后续帧（例如，是否缓存了 `RcvBase+1`, `RcvBase+2` 等）。
            *   将所有这些连续的已缓冲帧按序向上层交付。
            *   将 `RcvBase` 更新为下一个期望接收的按序帧的序号（即已交付帧的下一个序号）。
            *   接收窗口随 `RcvBase` 向前滑动（右移）。
    *   **如果序号小于 RcvBase（但不是太旧的重复帧）：** 可能是发送方重传的已确认帧。接收方可能会（根据具体实现）重新发送一个针对该序号的 ACK。
    *   **如果序号大于等于 RcvBase + W_R (在窗口外) 或过旧：** 认为该帧无效，丢弃该帧。

**3. 序号空间与窗口大小的关系 (N/2 规则):**

这是 SR 协议中最微妙也最重要的一点。在 SR 协议中，发送窗口大小 `W_S` 和接收窗口大小 `W_R` (通常 `W_S = W_R`) **必须小于或等于**总的序号空间大小 `N` 的一半，即 `W_S <= N/2`。

**为什么是 N/2？**

假设序号空间 `N = 4` (序号为 0, 1, 2, 3)，窗口大小 `W_S = W_R = 3`。

1.  **初始状态:** 发送方窗口 [0, 1, 2]，接收方窗口 [0, 1, 2]，RcvBase = 0。
2.  **发送方发送:** 发送帧 0, 1, 2。
3.  **接收方接收:** 接收方成功收到帧 0, 1, 2。它将它们交付上层，RcvBase 变为 3。接收方窗口变为 [3, 0, 1]。接收方为 0, 1, 2 发送 ACK。
4.  **灾难情景:** 假设所有针对帧 0, 1, 2 的 ACK 都丢失了。
5.  **发送方超时:** 帧 0, 1, 2 的定时器超时。发送方重传帧 0, 1, 2。
6.  **接收方收到重传的帧 0:** 接收方当前期望按序接收的是帧 3 (RcvBase=3)。它的接收窗口是 [3, 0, 1]。当它收到序号为 0 的帧时，它检查 0 是否在它的当前窗口 [3, 0, 1] 内。由于序号空间是模 N (4) 计算的，序号 0 **确实**在窗口 [3, 0, 1] 内 (等同于 [3, 4, 5])。
7.  **问题:** 接收方无法分辨收到的序号为 0 的帧是**第一次发送的**那个已交付的帧（因为 ACK 丢失导致的重传），还是**第二次发送的**（当发送方窗口滑动到 [3, 0, 1] 后发送的新一轮的）帧 0。因为窗口大小为 3，覆盖了序号空间的一半以上，导致新旧周期的序号在接收方窗口内产生了重叠，接收方无法区分。接收方可能会错误地将重传的旧帧 0 当作新帧接受并处理。

如果窗口大小 `W_S <= N/2` (例如 N=4, W_S=W_R=2)：

1.  **初始状态:** 发送方窗口 [0, 1]，接收方窗口 [0, 1]，RcvBase = 0。
2.  **发送方发送:** 帧 0, 1。
3.  **接收方接收:** 收到 0, 1。交付上层。RcvBase 变为 2。接收方窗口变为 [2, 3]。发送 ACK for 0, 1。
4.  **灾难情景:** ACK for 0, 1 丢失。
5.  **发送方超时:** 重传帧 0, 1。
6.  **接收方收到重传的帧 0:** 接收方当前期望按序接收的是帧 2 (RcvBase=2)。它的接收窗口是 [2, 3]。收到序号为 0 的帧。检查 0 是否在窗口 [2, 3] 内。不在。接收方可以确定这是一个旧的、重复的帧，并将其丢弃。

因此，为了避免这种“序号混淆”的问题，SR 协议要求窗口大小最大为序号空间的一半。

**SR 协议的优缺点:**

*   **优点:**
    *   在丢包率较高的网络中，通过只重传丢失的帧，可以显著提高传输效率和吞吐量，相比 GBN 性能更好。
    *   允许接收方接受失序帧，最大限度地利用网络带宽。

*   **缺点:**
    *   实现比停等和 GBN 复杂得多。
    *   发送方需要为每个未确认的帧维护独立的定时器（尽管实际实现中可能会进行优化）。
    *   接收方需要更大的缓冲区来存储失序到达的帧。
    *   接收方需要更复杂的逻辑来管理接收窗口、处理失序帧的缓存和按序交付。

**总结:**

选择重传协议通过允许接收方接受并缓冲失序帧，并只要求发送方重传丢失的特定帧，极大地提高了在不可靠信道上的数据传输效率。然而，这种性能提升是以更高的实现复杂度和更大的接收端缓冲区为代价的，并且受到窗口大小必须小于或等于序号空间一半的限制。它是许多现代可靠传输协议（如 TCP）基础思想的一部分（尽管 TCP 的实现比纯粹的 SR 更复杂，例如 TCP 采用累积确认并对重传策略有更灵活的处理）。